\input texinfo.tex      @c -*-texinfo -*-
@c %**start of header
@setfilename domterm.info
@documentencoding UTF-8
@settitle DomTerm - a terminal emulator and console using DOM and JavaScript

@syncodeindex fn cp
@syncodeindex vr cp
@syncodeindex pg cp
@codequoteundirected on
@codequotebacktick on

@titlepage
@title DomTerm - a terminal emulator and console using DOM and JavaScript
@end titlepage

@node Top
@top DomTerm

DomTerm is a combined terminal emulator and REPL console using web
technologies - i.e. JavaScript
and @uref{https://en.wikipedia.org/wiki/Document_Object_Model,DOM}:
Users can type commands which
gets sent to an application, which evaluates the command, and displays
the results, typically in some kind of type-script format.

This @uref{https://lwn.net/Articles/670062/,LWN article} provides
background, motivation, and a summary of the functionality.

The name ``DomTerm'' refers to that it  works by manipulating the
Document Object Model (DOM) of a browser: the nested structure of elements,
text, and attributes.
(Also, most other appropriate names were already taken...) 

DomTerm is Free Software (open-source)
available at @uref{https://github.com/PerBothner/DomTerm,https://github.com/PerBothner/DomTerm}.

The older @uref{https://github.com/PerBothner/JWebTerminal,JWebTerminal} project
was based on similar concepts, but was mostly written in Java using
@uref{https://docs.oracle.com/javafx/2/webview/jfxpub-webview.htm, Javafx WebView}.

@subheading Why another terminal emulator

@emph{}@image{images/domterm-1}
The goal of this project is to combine two related but
separate tools: a terminal emulator, and a rich-text console,
and do it properly.

There are many terminal emulators, including quite a few written in JavaScript.
However, they generally work with a rectangular grid of characters,
and don't integrate rich text (images, math, variable-width text,
variable-length lines, interaction) well.

There are also various tools designed for REPL-style interaction,
chat clients, etc. Examples include @uref{http://ipython.org/,IPython}
or the the JavaScript console of a web browser.
However, they don't work as terminal emulators, or at best have
limited functonality or require switching modes.

For rich text applications it seems obvious to use web technologies:
DOM and JavaScript.

One goal of this project is a stand-alone terminal emulator application
that techies can use as a day-to-day terminal emulator, and that also
seamlessly provides support for rich text and interaction. That means
an embedded web engine.

The core of the project is a JavaScript package that can be used and
embedded in different modes and applications.

@menu
* Features:: Features and screenshots
* Downloading and building::
* Applications::
* To do:: Ideas and projects for DomTerm
* Technical documentation::
@end menu

@node Features
@chapter Features and screenshots

@c The @emph is a dummy to force the @image inside a paragraph
@emph{}
@image{images/domterm-2}
A @strong{full-featured terminal emulator}, like @code{xterm}.
It is mostly compatible with setting @code{TERM=xterm-256color},
as many terminal emulators do.
Here you see the @code{mc} (Midnight Commander) file browser
running in the stand-alone DomTerm application.
@ifdocbook
(Click on image to see the full-size screenshot.)
@end ifdocbook
Emacs (shown later) and GNU readline also work well.

@emph{}@image{images/domterm-polygon-1}
A back-end @strong{can ``print'' images, graphics, and rich text}.
Here you can see evaluating and ``printing''
@code{Paintable} objects, which are graphical objects such as
filled polygons.
from the @uref{http://www.gnu.org/software/kawa/,Kawa} REPL.

The front page screenshot shows ``printing'' HTML for images and rich text.
(The expressions starting with @code{#<} are
@uref{http://www.gnu.org/software/kawa/XML-literals.html,XML literals},
which evaluate to @code{Element} objects. ``Printing'' an @code{Element}
inserts its HTML representation in the DomTerm output.)

The image later (with the yellow circle) shows printing
@uref{https://en.wikipedia.org/wiki/Scalable_Vector_Graphics,SVG}.

@emph{}
@image{images/emacs-in-firefox-1}
The guts of the implementation is portable JavaScript (@code{terminal.js}),
which can be @strong{embedded} in multiple front-ends.
The source includes a stand-alone terminal emulator,
using the embedded JavaFX WebEngine browser.
You can also use the included WebSockets server,
and along with your HTML5 browser of choice.
Here is @strong{Emacs displaying in a FireFox browser window}.

Applications of DomTerm include:
@itemize
@item
A chat/talk window.
@item
A read-eval-print-loop for an interactive scripting language.
@item
A command console.
@item
A terminal emulator.
@end itemize

User @strong{preferences are controlled a CSS stylesheet},
which can be changed by an application.

@strong{Uses a byte-protocol} to communicate with the back-end,
so can run in a browser (using web sockets);
be embedded in an application;
or run as a standard terminal emulator application.

Optional @strong{input editing}.  In @dfn{character mode},
each character is sent to the application, like a traditional terminal.
In @dfn{line mode}, the browser does the editing, and send the input line
to the back-end when Enter is typed.
A history of previous lines is available, accessible
with the Up/Down arrow keys.
@dfn{Automatic mode} switches between character mode and line mode
depending on whether the back-end is in ``@uref{http://www.gnu.org/software/libc/manual/html_node/Canonical-or-Not.html,canonical mode}''.

@emph{}@image{images/domterm-sh-svg}
@strong{Smart line-wrapping}: Remembers which lines were too wide (and thus
were wrapped).
The default style add markers to show when wrapping occurred,
as seen in the nearby screenshot.
Window size re-size will automatically re-do line-breaking.
Copying the selection as text will only include hard newlines.
Reports window resize to applicaton.
(Future: structure-based line-breaking aka pretty-printing.)

You can ``print'' @ref{Hide/show buttons,hide/show buttons},
using certain escape sequences.
The nearby screenshot shows the output of @code{ls -l} being hidden.

Handles Unicode.

Maintains @strong{a clean DOM structure}, and thus @strong{clean HTML export}.

Future: Optional automatic pagination.

@node Downloading and building
@chapter Downloading and building

@subheading Getting the DomTerm source code

The sources are in
a @uref{https://github.com/PerBothner/DomTerm,GitHub repository}.
To download the sources do:
@example
git clone https://github.com/PerBothner/DomTerm
@end example

@subheading Building from source

The core part of DomTerm is the JavaScript code @code{terminal.js},
which defines the @code{DomTerm} class.
You can use @code{terminal.js} in your own application.
However, there is also some utility code, include two standalone
terminal emulators.  These currently require Java (OpenJDK
works fine), though there are plans for a Java-less terminal emulator.

Building the sample applications and libraries is a two-part process:

First run the @code{configure} script:
@example
./configure @var{configure-options}
@end example
where @var{configure-options} can be:
@table @code
@item --with-java_websocket=/path/to/java_websocket.jar
Build a WebSocket server, using Java WebServer.
This allows using any modern browser as a front-end.
@item --enable-pty
Compile support for PTYs (pseudo-teletypes).
This allows character mode: sending individual characters *rather than lines)
from the front-end to the back-end.
This is the default, except on Windows (which doesn't support PTYs).
@item --with-javafx[=@var{library-name}]
Use JavaFX to run standalone applications.
The @code{@var{library-name}} if specified is either the @code{JAVA_HOME}
or a path to @code{jfxrt.jar}.
@end table
Then just:
@example
make
@end example

To test it, you can try:
@example
make run-firefox
@end example
This starts up a useable terminal emulator in a fresh window.
(It starts up a @code{bash} shell, running in a PTY,
with a WebSocket server.  It also starts a stripped-down Firefox window,
with no location bar or a menubar, using that for the input and output
of the @code{bash} shell.)

@node Applications
@chapter Applications

The core of DomTerm is the JavaScript @code{terminal.js},
but we also provides a few wrappers and applications that make use of it.
Currently, these all use Java, but I expect non-Java wrappers
to get written.

@subheading Standalone terminal emulator as a Firefox application

This is also a prototype of a stand-alone terminal emulator program.
It uses PTYs so it only works on Unix-like systems.
This is currently the preferred way of using DomTerm,
assuming it works for you.  You can start it with this command:

@example
make run-firefox
@end example

The user interface is a ``chrome-less'' Firefox browser window,
with a custom menubar, and custom
context menu (what you get by right-clicking).

This starts a @code{bash} shell, running in a PTY,
running along with a WebSocket server.  It also starts up
a chrome-less Firefox window, and automatically connects them.

Java is currently required for the WebSocket server, but
there are plans to replace that.

This is potentially a very nice terminal emulator.  However,
Firefox currently has undisagnosed performance issues when
many lines are written quickly.  (Chrome handles that better.)
Also, it is based on @uref{https://en.wikipedia.org/wiki/XUL,XUL},
which is being phased out.

@subheading Standalone terminal emulator as a Chrome application

This is very similar to using Firefox, but uses the Google Chrome browser.
This works well and the performance is good.
There are two ways you can do it.

The most convenient method just starts DomTerm
in a fresh chrome-less window (with no menubar or toolbar),
using the @code{--app=} option.  Doing the following
does the work for you: it starts both the WebSocket server,
the application (bash), and the Chrome browser window,
and connects them together:

@example
make run-chrome
@end example

This method provides no menubar or context-menu customization (so far).
Furthmore, @code{paste} doesn't work yet (though @code{copy} does).

It is also possible to start DomTerm as an actual
@uref{https://developer.chrome.com/apps/,Chrome app}.
This has working @code{paste} and the beginnings of a custom context-menu.
However, it is not as convenient or robust.
First you have to start up the server:
@example
make run-server
@end example
Then you have to start Chrome in a separate window:
@example
google-chrome --new-window --load-and-launch-app=/path/to/DomTerm/
@end example

(Help/advice for doing this better would be welcome.)

@subheading Standalone terminal emulator using JavaFX WebView

This is also a prototype of a stand-alone terminal emulator program.
It uses PTYs so it only works on Unix-like systems.
The prototype uses Java and the JavaFX WebView component (based on WebKit).
It needs OpenJDK 1.8 but should otherwise not need anything else.

To run the terminal emulator do:

@example
make run-pty
@end example

or equivalently:

@example
java -Djava.library.path=@var{libpath} -jar domterm.jar --pty
@end example

The @var{libpath} is the directory containing @code{libpty.so}.
It is also used to set the @code{TERMINFO} environment variable,
hence the terminal description file should be @code{@var{libpath}/d/domterm}.

There is a bug with the initial communication - you may
have to hit an extra Enter to get started.

There is no "chrome" (menus, buttons, etc), so far.
Right-clicking will bring up a popup menu
This supports copy and paste, as well as switching the input mode
between line, character, or auto mode.

By default the command is @code{/bin/bash}.  You can override it by
specifying a command after the @code{--pty} flag:

@example
java -Djava.library.path=@var{libpath} -jar domterm.jar --pty @var{command} @var{arg}...
@end example

@subheading A console for a Java Process object

This is similar to the previous terminal emulator,
but it is implemented using pipes connected to Java @code{Process} object.
This means only line mode is supported.
It should work on more platforms, including Windows, since it
doesn't use a PTY.  It still uses JavaFX WebView.

You can run it from @code{domterm.jar}:
@example
java -jar domterm.jar --process @var{command} @var{arg}...
@end example

@subheading Running a Java class connected to DomTerm

This runs the @code{main} method of a specified Java class,
but with the standard streams (input, output, and error)
re-bound to a DomTerm window. (The latter still uses JavaFX WebView.)

@example
java -cp @var{my-application.jar}:domterm.jar org.domterm.javafx.RunClass @var{my.ClassName} @var{arg}...
@end example

@subheading Using WebSockets between a server and a browser

This allows you to use "any" modern browser as the client.
This is nice for development, as you can use the browser's
JavaScript console and debugger, DOM inspector, and so on.
The browser talks to server using WebSockets.

The included server uses @uref{http://java-websocket.org/,Java-WebServer},
which is very compact and light-weight.
The @code{java_websocket.jar} is checked in for convenience
(though that may change).

To run the server you can do:
@example
make run-server SERVER_ARGS=@var{server-args}
@end example
or equivalently:
@example
java -cp domterm.jar:java_websocket.jar -Djava.library.path=@var{libpath} org.domterm.websocket.DomServer @var{server-args}
@end example
The @var{libpath} is as above.  The optional @var{server-args} have the form:
@example
[--port @var{port-number}] [--pty | --process] [@var{command} @var{arg}...]
@end example
The @var{port-number} is the port to listen to; it defaults to 8025.
The other flags similar to those for the standalone and console applications.
The default is to use PTYs, if available or @code{--pty} is specified.
The default for @var{command} is @code{/bin/bash}.

To connect to the server, 
use a web brower to read @code{file:///path/to/DomTerm/repl-client.html}.

Each connection to the server creates a new process, but using the
same @var{command} and @var{arg}s.
(Multiple connections using @code{--process} will fail for some
unknown reason.)

(An older WebSocket server uses libraries from the
@uref{https://tyrus.java.net/,Tyrus project}.
These libraries are much bigger, but this implementation
could be suitable for a JavaEE environment as it follows JSR-356.)

(If using PTYs, which requires native code anyway, it may be better
to use a server written in C or C++, such as
@uref{https://libwebsockets.org/index.html,libwebsockets}.)

@node To do
@chapter Ideas and projects for DomTerm

@subheading Basic terminal emulator functionality

@subsubheading Make robust enough for actual use

This means supporting all the ``base'' functionality
of xterm as implemented by terminal emulators that
set @code{TERM} tp @code{xterm-256color}.

The most important missing functionality is handling mouse clicks and
other mouse events compatibly with @code{xterm}.

Other terminal emulators:

@uref{https://github.com/chjj/term.js/,term.js}
has quite complete terminal emulation and even better documentation.
Howewver, it's based on a simple 2-d array (char value and attributes
encoded as an integer).

@subsubheading Document any discrepances from xterm

While implementing all of the
@uref{http://invisible-island.net/xterm/ctlseqs/ctlseqs.html,features of xterm}
is probably not feasible, we should at least have a list of
anything we don't implement, or implement differently from xterm.

@subsubheading  Use vttest for testing

The xterm distribution includes @uref{http://invisible-island.net/vttest/,vttest}.
Many of the tests work now, but there are more worth fixing.

@subsubheading Support Sixel graphics

@uref{https://en.wikipedia.org/wiki/Sixel,Sixel} is an old raster
image format supported by DEC terminals and some programs, including xterm.
It is interesting because some programs (such as gnuplot) can use Sixel
to interleave graphics and text, without requiring separate windows.

This @uref{http://www.xarg.org/2010/03/generate-client-side-png-files-using-javascript/,JavaScript utility} may be useful in converting raster data (post-sixel-decoding) to PNG, which could the be displayed with a @code{data:} URI.
Alternatively, a @code{<canvas>} element could be used.

@subsubheading Improve copy and paste

Handle exporting html to clipboard.

Implement Ctrl-Shift-C as copy and Ctrl-Shift-V as paste.
(At least in standaline ptyconsole.App, as there may be security
problems when using a normal browser.)

Fix paste in line-editing mode.

Think about how to do multi-line paste.

@subheading Better stand-line terminal emulator

Should probably have a (hideable) top menubar (in additon to pop-up menu).

Allow switching styles.

Handle saving and truncating scrolled-out output.

@subheading Support other embeddable browsers

Evaluate using other ligher-weight (?) toolkits than JavaFx WebView.

Rather than using JavaFX WebView, some other toolkits to consider include:
@itemize
@item
@uref{https://bitbucket.org/chromiumembedded/cef,Chromium Embedded Framework}
@item
@uref{http://lwn.net/Articles/647921/,Mozilla Servo}
@item
@uref{http://atom.io,Atom/Electon}
A possible start is @uref{https://atom.io/packages/term2,term2}.
@item
QtWebEngine seems promising for a general-purpose terminal emulator front-end:
It supports WebSockets, tabs, remote debugging, is multi-platform,
and is actively maintained.
@item
@uref{http://webkitgtk.org/,WebKitGtk+}
@end itemize

@subheading Readline style hooks and improvements

The idea is the line-editing mode would provide the
functionality of readline or similar programs.

@subsubheading Improved history support in line-editing mode

While DomTerm has basic history support (previous/next line),
we should implement searching (ctrl-R in readline),
as well as saving the history (in local storage).

@subsubheading Readline hooks to recognize when it's running under DomTerm

The idea is readline would delegate basic line editing
(and re-display) to DomTerm, while DomTerm would call back
to readline for command completion, history, etc.

This has a couple of advantages over plain readline:
One is to have mousing actually work (i.e. no more
readline not being able to move the cursor on mouse-clicks).
Another advantage is local editing, which is a benefit
over slow links (such as satellites) or when you don't
want to interrupt the server needlessly.

Readline should at least behave as if the screen width were infinite,
delegating line-wrapping to DomTerm.

@subsubheading Customizable key sequences, as in readline

@subheading Pretty-printing

Add hooks for Lisp-style pretty-printing.  The idea is a pretty-printer
woudl emit groups and "text blocks" and DomTerm would do line-breaking.
Specifically, lines would be re-broken on window size change.

@subsubheading Integrated pagination (like more/less)

Emacs term mode does this.

@subsubheading Graphics hooks

Allow processes to send HTML and graphics to DomTerm.
See some previous work: http://per.bothner.com/blog/2007/ReplPane/

@subsubheading Allow printing images

A REPL might want to "print" an image which we want to display.
This could use a blob: or data: URL (neither of which are universally
supported) or create a URL to a temporary file.

@subsubheading Event forwarding to inferior

A process may "print"/paint graphics with event handlers.
For example a button.  On clicking the button, the click
should be bundled as an event objects sent back to the inferior.

@subheading Saved notebooks

A "notebook" is a saved (and potentially executable)
representation of a session.

IPython/Jupyter has a
@uref{https://ipython.org/ipython-doc/3/notebook/nbformat.html,JSON encoding for "notebooks"}.
This is flexible and extensible, but requires special tools.

The DomTerm notebook format should just be a simple html page.
Essentially a serialization of the DOM.  The page may include
some generated header information and metadata.  It may include
references to JavaScript that would allow former execution,
as well as viewing actions (like hide/unhide, wrap-to-fit, etc).
This references should be simple and relative, so the actual
JavaScript loaded can depend on context.

The format must be XML-compatible (XHTML) so it can be
parsed by XML tools such as XSLT.

Specific format TBD.

The html page must be viewable and look reasonable in a browser even
if JavaScript library or style files are missing or JavaScript is
disabled.

A notebook may be include additional resources in other files,
such as images.  If notebook  consists of multiple files,
they should be bundled in a zip archive (like LibreOffice does).

Tools to convert to and from Jupyter format would be nice,
so we should avoid gratuitous conceptual incompatibility.

@node Technical documentation
@chapter Technical documentation

@menu
* DOM structure::
* Wire byte protocol::
* The DomTerm JavaScript class::
* Architecture notes::
@end menu

@node DOM structure
@section DOM structure

The JavaScript code works by DOM manipulations of
a top-level @code{div} element, and assume that element
has a certain well-behaved form.

@table @asis
@item @var{domtern-element} ::= @code{<div class="domterm">} @var{domterm-toplevel} @code{</div>}
A top-level ``DomTerm window'' is a @code{<div>} element
whose @code{class} is @code{domterm}.

@item @var{domterm-toplevel} ::= @var{internal-div-elements} @var{block-content}@sup{*}

You don't need to create @var{domterm-toplevel} - it is created and managed by
DomTerm, based on data from the back-end.

Currently, the @var{block-content} is a single
@code{<div class="interaction">}
with an @code{id} attribute of the form @code{@var{xxx}_main}.
This is the xterm ``normal screen buffer''.

More structure will be supported, for example individual @code{<div>}
to wrap each command and its output.

@item @var{internal-div-elements}
One or more invisible @code{<div>} elements used by the implementation.

@item @var{block-content} ::= @var{logical-line} | <div> @var{block-content}@sup{*} </div> | @var{opaque-line}

@item @var{logical-line} := @var{<pre>} @var{line-content}@sup{*} @var{hard-nl} @code{</pre>} | @var{<p>} @var{line-content}@sup{*} @var{hard-nl} @code{</p>}
A @var{logical-line} is one or more ``rows'' (separated by @var{soft-line}s),
consistening of character and other @code{inline} data,
ending with @var{hard-nl} representing an explicit newline.

The intent is that @code{<pre>} and @code{<p>} are treated logically
the same, but @code{<pre>} will be monospace,
while @code{<p>} can use other fonts and styling.
The line-breaking algorithm uses the width of the line,
not the number of characters, so it should also work for @code{<p>} elements.
Normal terminal output will create @code{<pre>} elements.

@item @var{line-content} ::= @var{text} | @code{<span>} @var{line-content}@sup{*} @code{</span>} | @var{soft-nl} | @var{input-line} | @var{other-content}

@item @var{hard-nl} ::= @code{<span line="hard">&#A;</span>}
An explicit newline. Has a @code{"\n"} text node as its sole child.

@item @var{soft-nl} ::= @code{<span line="soft"></span>}
An implicit newline, inserted by DomTerm when a line overflows.
Has no explicit text content, but CSS adds a @code{"\n"}
as @code{before} content.
CSS by default also add a continuation arrow.

@item @var{input-line} ::= @code{<span id="input1" std="input" contenteditable="true">} @var{text} @code{</span>}
The location of the input cursor.
In char-mode the @var{text} is empty.  In line-mode contains
the current input line.  Also used for previous input lines,
but without @code{contenteditable} set.
Referenced by the @code{inputLine} field of the DomTerm object.

@item @var{opaque-line}
A non-empty block-level element that isn't navigable
at the level of rows and columns.
For example a @code{<table>}.
It is treated as a single empty line.
@end table

@anchor{command group}
@subsubheading Command groups

A @dfn{command group} is the set of input and output lines for a single
user command.

@table @asis
@item @var{command-group} ::= @code{<div class="command-group">} @var{command-input-line}@sup{+} @var{command-output}@sup{?} @code{</div>}
Usually there is a single @var{command-input-line},
but there may be more than one if there are continuation lines.
@item @var{command-input-line} ::= @code{<pre>} @code{<span std="prompt">} @var{prompt-text} @code{</span>} @code{<span std="input">} @var{input-text} @code{</span>} @code{</pre>}
A @var{command-input-line} is @code{logical-line} which (at least normally)
has the form of a prompt followed by the typed input command.
@item @var{command-output} ::= @code{<div class="command-output">} @var{block-content}@sup{+} @code{</div>}
The output from the command.
Normally, each @var{block-content} is a @var{logical-line}.
The @code{<div class="command-output">} element may have the
@code{domterm-hidden} attribute if it is hideable.
@end table

@anchor{Hide/show buttons}
@subsubheading Hide/show buttons

A hide/show button is a clickable toggle ``button'' that controls
whether certain ``associated output'' is shown or hidden.
For example the ``associated output'' of a shell command could be the
set of output lines from the command.  Initially, the output is in
the shown state, and the button displays a ``hide'' icon.
Clicking the button will hide output lines, as well as changing the
button to display a ``show'' icon.  Clicking the button again
changes the icon to the ``hide'' icon and unhides the output lines.

@table @asis
@item @code{<span std="hider"} [@code{domterm-hiding="true"} or @code{"false"}]@code{>} @var{hide-icon} @code{</span>}
This is a hide/show button.  The @var{hide-icon} is either empty or one of
the strings with odd-numbered index in DomTerm's
@code{showHideMarkers} property.
The value of the @code{showHideMarkers} property is an array of strings,
where the even-numbers elements are ``show'' icons, and
the following odd-numbered elements are the corresponding ``hide'' icons.
It is suggested (but not required) that these icons be single
graphic characters.
Good choices are @code{"\u25B6"} (@code{@U{25B6}} ``black right-pointing triangle'')
for ``show'', and
@code{"\u25BC"} (@code{@U{25BC}} ``black down-pointing triangle'') for ``hide''.

The attribute @code{domterm-hiding} must be @code{"true"}
or @code{"false"}; if missing it defaults to @code{"false"}.
Its value is flipped on each click,

If you are unsatisfied with the existing icon choices you can
either set @code{showHideMarkers} to other strings,
or you can use CSS to change the look of the icons.
For example to use @code{[-]} and @code{[+]} use these CSS rules:
@example
span[std="hider"][domterm-hiding="true"]:after @{ content: "[+]" @}
span[std="hider"]:after @{ content: "[-]" @}
@end example
In this case, you probably want the @var{hide-icon} text in
the @code{<span>} to be empty.
@end table

The ``associated output'' for a hide/show button
is the set of sibling elements following the button,
as well as sibling elemets of the button's parent
(assuming that parent is a @code{<pre>} or @code{<p>} element).
Only elements that have the @code{domterm-hidden} attribute are affected.
Hiding is done by changing the value the @code{domterm-hidden} from
@code{"false"} to @code{"true"}; un-hiding changes it back to @code{"false"}.
This is using a CSS style rule that sets the @code{display} property
of an element to @code{none} when @code{domerm-hidden} is @code{true}

A future extension would allow @emph{lazy} associated output:
The initial state is hidden, and the back-end does not provide
the output until it is requested, by clicking the hide/show button.
Lazy output is useful for displaying and inspecting large
(or even infinite) data structures, such as as a directory hierarchy
or a complex object graph.

@subsubheading Alternate screen buffer

Xterm supports an ``alternate screen buffer'' which is used
by character-based programs like emacs.
Switching to the alternate buffer creates a new @code{<div class="interaction>},
with an @code{id} attribute of the form @code{@var{xxx}_alternate}.
It is the sibling of the normal screen buffer
(with @code{id} attribute of the form @code{@var{xxx}_normal}).
This @code{<div>} contains one or more @var{logical-line}s.
Returning to the normal screen deletes the @code{<div>} for the
alternative screen, along with all of its contents.

@node Wire byte protocol
@section Wire byte protocol

DomTerm mostly handles standard @uref{https://en.wikipedia.org/wiki/ANSI_escape_code,ansi/xterm escape sequences}.
This section documents DomTerm-specific extensions.
(@emph{Future:} We should also document what xterm features aren't implemented.)

@strong{The following are preliminary code sequences,
which may change based on experience and feedback.}

@emph{Notation:}
Literal characters are written as quoted string literals with
escape sequences as understoof by bash's @code{echo -e}.
Specifically @code{"\e"} is an escape; @code{"\a"} is alert (bell);
@code{"\xHH"} is the 8-bit characters whose value is HH (hexadecimal).

@subsection Special sequences sent by back-end and handled by DomTerm

@table @asis
@item @code{"\e[3J"}
Erase the scrollback buffer (i.e. any lines above the home line).
(This is an xterm feature.)

@item @code{"\e]72;" @var{html-text} "\a"}
Insert HTML text.

The HTML is sanity-checked for safety.
It needs to be well-formed XML; thus to write a horizontal line
you must write @code{<hr/>} (with the extra ``@code{/}'').

The actual policy for allowed elements and attributes
can be changed by overwriting the @code{elementInfo}
and @code{allowAttribute} functions in @code{terminal.js}.
The default policy is a work-in-progress.

@item @code{"\e]74;" key "\a"}
Simulate pressing @var{key}.  Used by auto-line mode.

@item @code{"\e[12u"}
Start of error output.
DomTerm places the following text inside a @code{<span>} element
whose @code{std} attribute has the value @code{"error"}.
The default style is to display the text in red.

@item @code{"\e[11u"}
End of error output.

@item @code{"\e[14u"}
Start of prompt.
DomTerm places the following text inside a @code{<span>} element
whose @code{std} attribute has the value @code{"prompt"}.
The default style is to display the text in green.

@item @code{"\e[13u"}
End of prompt.

@item @code{"\e[15u"}
Start of an input line.
This also implicitly ends a prompt.
The input line is implicitly terminated by a @code{'\n'}
(carriage return).

@item @code{"\e[16u"}
@itemx @code{"\e[17u"}

Delimit a @ref{Hide/show buttons,hide/show "button"}, with @code{"\e[16u"} before
and @code{"\e[17u"} after.

@item @code{"\e[19u"}

Start a @ref{command group}.
This command implicitly ends any existing command group.
You can write this string before writing
an input prompt string.
@end table

These escape sequences work pretty well in prompt strings,
for example for GNU readline or a shell's @code{PS1} variable.
You can place the following in your @code{~/.bashrc}
to cause @code{bash} to emit these escape sequences:
@example
PS1='$ '   # or whatever you like
if [ -n "$DOMTERM" ]
then
  PS1='\[\e[19u\e[16u\]▼\[\e[17u\e[14u\]'$PS1'\[\e[15u\]'
fi
@end example
(The @code{"\["} and @code{"\]"} are bash syntax,
and are equivalent to readline's @code{"\001"} and @code{"\002"}.
They are used to indicate escape sequences that don't move the cursor,
which is needed for readline to calculate the column position.)

@table @asis
@item @code{"\e[20;97u"}
@itemx @code{"\e[20;99u"}
@itemx @code{"\e[20;108u"}
@itemx @code{"\e[20;112u"}
Set input editing mode.
The value 99 (@code{'c'}) sets character mode;
the value 108 (@code{'l'}) sets line-editing mode.
The value 97 (@code{'a'}) set automatic mode,
which switches between character mode and line-editing mode
based on the mode of the inferior process (when using a PTY).
The value 112 (@code{'p'} for "pipe") is like line-editing mode,
but the inferiors doesn't echo the input, so we have to do it.
This mode is useful when the input is a pipe or some other non-tty stream.

@item @code{"\e[99;99u"}
End-of-file on the output stream.
Calls the @code{eofSeen} method of @code{DomTerm},
which may close the current window or other appropriate action.
@end table

@subsection Special sequences sent by DomTerm to back-end

@table @asis
@item @code{"\x92" @var{name} " " @var{data} "\n"}
General format for reporting events,
where @var{name} is the name of the event (an identifier).
The @var{data} can be any text not including a @code{"\n"}
(or other control character); JSON format is used in some cases.

@item @code{"\x92" "WS " @var{rows} " " @var{cols} " " @var{height} " " @var{width} "\n"}
Report window size from DomTerm to the back-end.

@item @code{"\x92" "KEY " @var{kcode} " " @var{kchars} "\n"}
Used by auto-line mode to report a key event to back-end.
The @var{kcode} is a numeric key code,
while @var{kchars} is as string literal (JSON-formatted)
of the characters that are normally transmitted to the back-end.
(If the events was a key-press event, the @var{kcode} is negated first.)
In auto-line mode, if the pty is in canonical mode, then @var{key}
is returned to DomTerm (using @code{"\e]74;" @var{key} "\a"});
otherwise @var{kchars} are sent to the pty.

@item @code{"\x92" "ALINK " @var{href} "\n"}
Sent by the DomTerm browser when the user clicks on an @code{<a>} link.
The backend should open @var{href} (which is JSON-encoded)
in the default browser of the user's desktop.
(In the future to better support remote desktops, the backend
should support a proxy server: The @var{href} should be resolved
based on the backend's environment.)

@item @code{"\x92" "VERSION " @var{version-info} "\n"}
Sends @var{version-info} to the back-end.  Used during initialization.
@end table

@node The DomTerm JavaScript class
@section The DomTerm JavaScript class

A DomTerm instance encapsulates the
state of a terminal emulator / console.

Functions and properties not documented here should be considered
internal and (more) likely to change.

@deftypefun new DomType (@var{name})
Create a new DomTerm instance.
The parameter @var{name} is a string.
If you have multiple DomTerm instances, it is a good idea
for the names to unique, but currently nothing depends on that.
@end deftypefun

@defun initializeTerminal (element)
Initialize the DomTerm, and associate it with the give @var{element}
(which should be a @code{<div>} element that has @code{class="domterm"}).
This creates the @uref{DOM structure,sub-structure} of child elements
of @var{element}.
@end defun

@defun insertString (str)
Interpret and insert the characters of @var{str}.
If may have ANSI/xterm @ref{Wire byte protocol,escape sequences}.
This method is called by the DomTerm client code.
@end defun

@defun processInputCharacters (str)
Send @var{str} to the client,
where @var{str} consists of typed characters and other events.
This is a callback function that must be set by the client.
This is called by the DomTerm code in @code{terminal.js}.
@end defun

@defun reportEvent (name, data)
Called by DomTerm to notify the client that some (non-character) event happened.
The default action calls @code{processInputCharacter}
with a special sequence starting with @code{"\x92"} followed
by the @var{name}, space, the @var{data} and a newline.
@end defun

@defun setWindowSize (numRows, numColumns, availHeight, availWidth)
Called by DomTerm when the window changes size, or the (font) style changes
so the number of rows or columns has changed.
Is used to notify the client.  The default behavior is to
call @code{reportEvent} with a @code{"WS"} event type.
@end defun

@defun doPaste ()
Handles a @code{paste} operation.
May be called by client code.
May also be overridden if needed; the default uses @code{execCommand},
which triggers a @code{paste} event.
It is called by DomTerm if the user types Ctrl-Shift-V.
@end defun

@defun pasteText (text)
Called by the @code{paste} event handler.
Actually handle a paste event.
@end defun

@defun doCopy ()
Handles a @code{copy} operation.
May be called by client code.
May also be overridden if needed; the default uses @code{execCommand}.
It is called by DomTerm if the user types Ctrl-Shift-C.
@end defun

@defun setInputMode (mode)
Set the input editing mode.
The value 99 (@code{'c'}) sets character mode
(each keystroke is sent to the client);
the value 108 (@code{'l')} sets line mode
(local line editing with a complete line sent on enter);
the value 97 (@code{'a'}) sets automatic mode
(switch between line and character modes depending on client pty state);
the value 112 (@code{'p'}) sets pipe mode
(like line mode but with local echoing).
@end defun

@defun doLineEdit (key, str)
Handle keyboard event when doing input line editing ourselves,
rather than depending on the default action.
This is used  if the @code{useDoLineEdit} property is set.
It is also used for the first character in automatic input editing mode.
(In that case we can't use the browser default action, since we
first have to check the input mode of the client.)
@end defun

@defun handleBell ()
Called when ctrl-G (the @code{bell} character) is seen.
The default action is to do nothing.
@end defun

@defun handleLink (event, href)
Called on a click event on a @code{<a>} link element.
The default action is to call @code{preventDefault} on the @var{event},
and then call @code{reportEvent} with an @code{"ALINK} type event.
(We can't let the browser do its default action since that would
replace the current DomTerm page.)
@end defun

@defun setWindowTitle (title, option)
Set the title of the containing window.
Called by DomTerm when it sees certain @code{xterm}-style escape sequences.
The @var{option} controls whether the icon name should be set;
it is currently ignored.
@end defun

@defun elementInfo (tag, parents)
Overridable function called by the HTML sanitizer.
@end defun

@defun allowAttribute (name, value elementInfo, parents)
Overridable function called by the HTML sanitizer.
@end defun

@node Architecture notes
@section Architecture notes

@example
            --------------------
 Front-end  |  Display and keyboard
            |---------------
            |  Browser engine (runs terminal.js)
            |---------------
            |  Communication stub
            ---------------
              ^
              | Optional network
              V
            --------------------
  Back-end  |  Communication stub
            |---------------
            |  Application
            ---------------
@end example

The DomTerm architecture allows for multiple front-end
implementations and multiple back-end implementations.
The front-end runs the actual terminal emulator (written in JavaScript)
and manages the display. The front-end can be a window or tab in a
general-purpose browser like Firefox or Chrome, or it can be a
special-purpose browser optimized for DomTerm. The latter would drop
the URL bar, add a menu bar and other controls as more suitable
to a terminal emulator, and tweak a few minor security restrictions.

The back-end runs the actual application.
The application can be a general-purpose shell, or a custom application,
such as a programming language run-time or a chat server.
The back-end can run the application under a PTY.
Alternatively, the application can communicate using pipes,
if you prefer to avoid PTYs or they are unavailable (as on Windows).

The front-end and back-end can be combined in the same process,
using an embeddable browser.
The current @ref{Applications,sample applications}
include a single-process terminal emulator that uses the JavaFX WebEngine,
a JavaFX pop-up menu, and a PTY class.
In this case the ``communication stub'' is WebEngine's
bridge between JavaScript and Java, plus communicating with the PTY.
A C/C++ application could similarly use QtWebEngine
and its C++/JavaScript bridge.

If the front-end and back-end are separate processes, they can
communicate using a byte-stream protocol.
Currently we stick to well-formed UTF8, because JavaScript's
support for byte arrays is still weak.
The protocol is based on the xterm protocol: text and escape sequences
from the application to the front-end; keystrokes and encoded events
sent the other way.  More complex data can be encoded using JSON.
Most of protocol is handled by @code{terminal.js}.
The communications stubs may generate or intercept some messages:
For example a PTY stub will want to handle window size change events.

These data streams can be layered on top of other protocols,
such as telnet, ssh, or WebSocket.
Using WebSocket is convenient because it is built in to modern browsers,
so the entire front-end (except @code{terminal.js})
is readily available.

@subsection A roadmap

This is my vision of how terminals should be done in 2016.

The ``terminal emulator'' application that a user runs
(for example by clicking an icon or from an existing command line)
should be a small program that parses command-line arguments,
then fires up (if necessary) a front-end process and a back-end process,
and connects the two.
This application would have an option to connect to an existing
back-end session, supporting the functionality of GNU Screen.

The default front-end (unless otherwise specified on the command line)
is a custom web browser optimized for use as a terminal/console - for
example it drops the URL bar, and instead automatically loads the
terminal emulator web-app.  The front-end communicates with the backend using
WebSockets. @uref{https://wiki.qt.io/QtWebEngine,QtWebEngine}
seems like a promising base: It supports WebSockets, tabs, remote debugging,
is multi-platform, and is actively maintained.

The default backend would be a small WebSocket server that forks
off a user process, by default using a PTY (when available), otherwise
using pipes.
It would be helpful if the back-end can also serve http/https, for
serving the initial html page and JavaScript (unless those could be
builtin to the front-end).  A builtin http server could also
support images and other non-textual data, if you don't want to
include it directly in the output,
possibly using a @code{@uref{https://en.wikipedia.org/wiki/Data_URI_scheme,data}} URI.
The @uref{https://libwebsockets.org/index.html,libwebsockets}
library seems a possible base for a WebSockets+http server.

More blue-sky, it would be nice if the terminal subsystem and/or the C library
could have a special mode for PTYs running under DomTerm.
For example, the terminal driver should not do canonical-mode
input-line cooking, but should delegate that to DomTerm.
(DomTerm approximates this by monitoring the terminal @code{canon}
flag, but a more robust protocol would be better.)
Type-ahead could also work better.
It would also be nice to delimit output to standard error with the
appropriate escape sequences.

@subsection Line vs character input modes

In line input mode we can end up with double echoing:
As you edit the input line, it is displayed.
Then when the line is sent, the slave will normally echo the input.

Ideally you'd want to integrate with the kernel
terminal sub-system, to suppress echoing.   In lieu of
that, line editing mode could delete the input line
from the DOM before sending them to the inferior.
To avoid annoying flashing, this is done lazily:
DomTerm waits to remove the input line until it gets some
output from the inferior (usually the echo).

In addition to "char mode" and "line mode" (like the
Emacs term mode) there is an "auto mode" which watches
the states of the inferior pty to automatically switch
between them.  In autoEditing mode, if we're currently
in char mode, then a key event gets sent to the pty layer.
If the pty is in non-canonical mode, the key event is
sent to the server.  If the pty is in canonical mode, then
a message is sent back to the front-end, which switches
to line mode, and processes the event.

@subsection Line structure

"Line" here refer to "visual line": A section of the DOM that should be
treated as a line for cursor movement.  Line breaks may come from the
back-end, or be inserted by the line break algorithm.

The lineStarts array maps from a line number to the DOM location
of the start of the corresponding line.

The lineEnds array maps to the end of each line.
Always points to a span node with the line attribute set.
Normally lineEnds[i] == lineStarts[i+1]; however, sometimes
lineStarts[i] is the start of a @code{<div>} or other block element.

@subsection Colors and high-lighting

@emph{This needs updating.}

Escape sequences (for example @code{"\e[4m"} - "underlined", or
@code{"\e[32m"} - "set foreground color to green") are translated to
<span> elements with "@code{style}" attributes (for example
`<span style="text-decoration:underline">` or `<span style="color: green">`).
After creating such a `<span>` the current position is moved inside it.

If we've previously processed "set foreground color to green", and we
see a request for "underlined" it is easy to ceate a nested `<span>`
for the latter.  But what if we then see "set foreground color to red"?
We don't want to nest <span style="color: red">` inside
<span style="color: green">` - that could lead to some deep and
ugly nesting.  Instead, we move the cursor outside bot existing
spans, and then create new spans for red and underlined.

The `<span>` nodes are created lazily just before characters are
inserted, by `_adjustStyle`, which compares the current active styles
with the desired ones (set by `_pushStyle`).

A possibly better approach would be to match each highlight style into
a `class` attribute (for example `green-foreground-style` and
`underlined-style`).  A default stylesheet can map each style class to
the correspoding CSS rules.  This has the advantage that one could
override the highlighting appearance with a custom style sheet.

@subsection Line-breaking / pretty-printing

For a terminal emulator we need to preserve (not collapse) whitespace,
and (usually) we want to line-break in the middle of a word.

These CSS properties come close:
@example
white-space: pre-wrap; word-break: break-all
@end example
This is simple and fast.  However:
@itemize
@item
It doesn't help in inserting a visual indicator, like Emacs's arrow,
  to indicate when a line was broken.
@item
It doesn't help managing the line table.
@item
It doesn't help with pretty-printing (for example grouping).
@end itemize

Hence we need to do the job ourselves.

Define a DOM API for (LISP-style) pretty-printing.
Line-breaking is re-calculated on page width change.

@table @asis
@item @code{<span line="fill">}
@itemx @code{<span line="linear">}
Line break types, as in Common Lisp.

@item @code{<span class="group" ident=N">}
@end table

Derek Oppen algorithm

Stable, Flexible, Peephole Pretty-Printing
http://macbeth.cs.ucdavis.edu/ph-final.pdf
